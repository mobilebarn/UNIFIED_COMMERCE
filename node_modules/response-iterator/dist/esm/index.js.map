{"version":3,"sources":["/Users/kevin/Dev/OpenSource/http/response-iterator/src/index.ts"],"sourcesContent":["import type { AxiosResponse } from 'axios';\nimport type { Response as NodeResponse } from 'node-fetch';\nimport type { Readable as NodeReadableStream } from 'stream';\n\nimport asyncIterator from './iterators/async.js';\nimport nodeStreamIterator from './iterators/nodeStream.js';\nimport promiseIterator from './iterators/promise.js';\nimport readerIterator from './iterators/reader.js';\n\ninterface CrossFetchResponse {\n  _bodyBlob: Blob;\n}\n\nconst hasIterator = typeof Symbol !== 'undefined' && Symbol.asyncIterator;\n\n/**\n * @param response A response. Supports fetch, node-fetch, and cross-fetch\n */\nexport default function responseIterator<T, TReturn = unknown, TNext = unknown>(response: unknown): AsyncIterableIterator<T, TReturn, TNext> {\n  if (response === undefined) throw new Error('Missing response for responseIterator');\n\n  // determine the body\n  let body: unknown = response;\n  if ((response as NodeResponse).body) body = (response as NodeResponse).body;\n  // node-fetch, browser fetch, undici\n  else if ((response as AxiosResponse).data) body = (response as AxiosResponse).data;\n  // axios\n  /* c8 ignore start */ else if ((response as CrossFetchResponse)._bodyBlob) body = (response as CrossFetchResponse)._bodyBlob; // cross-fetch\n  /* c8 ignore stop */\n\n  // adapt the body\n  if (hasIterator && body[Symbol.asyncIterator]) return asyncIterator<T, TReturn, TNext>(body as AsyncIterableIterator<T, TReturn, TNext>);\n  /* c8 ignore start */\n  if ((body as ReadableStream<T>).getReader) return readerIterator<T, TReturn, TNext>((body as ReadableStream<T>).getReader());\n  if ((body as Blob).stream) return readerIterator<T, TReturn, TNext>(((body as Blob).stream() as unknown as ReadableStream<T>).getReader());\n  if ((body as Blob).arrayBuffer) return promiseIterator<T, TReturn, TNext>((body as Blob).arrayBuffer() as unknown as Promise<T>);\n  if ((body as NodeReadableStream).pipe) return nodeStreamIterator<T, TReturn, TNext>(body as NodeReadableStream);\n  /* c8 ignore stop */\n\n  throw new Error('Unknown body type for responseIterator. Maybe you are not passing a streamable response');\n}\n"],"names":["asyncIterator","nodeStreamIterator","promiseIterator","readerIterator","hasIterator","Symbol","responseIterator","response","undefined","Error","body","data","_bodyBlob","getReader","stream","arrayBuffer","pipe"],"mappings":"AAIA,OAAOA,mBAAmB,uBAAuB;AACjD,OAAOC,wBAAwB,4BAA4B;AAC3D,OAAOC,qBAAqB,yBAAyB;AACrD,OAAOC,oBAAoB,wBAAwB;AAMnD,MAAMC,cAAc,OAAOC,WAAW,eAAeA,OAAOL,aAAa;AAEzE;;CAEC,GACD,eAAe,SAASM,iBAAwDC,QAAiB;IAC/F,IAAIA,aAAaC,WAAW,MAAM,IAAIC,MAAM;IAE5C,qBAAqB;IACrB,IAAIC,OAAgBH;IACpB,IAAI,AAACA,SAA0BG,IAAI,EAAEA,OAAO,AAACH,SAA0BG,IAAI;SAEtE,IAAI,AAACH,SAA2BI,IAAI,EAAED,OAAO,AAACH,SAA2BI,IAAI;SAEvD,IAAI,AAACJ,SAAgCK,SAAS,EAAEF,OAAO,AAACH,SAAgCK,SAAS,EAAE,cAAc;IAC5I,kBAAkB,GAElB,iBAAiB;IACjB,IAAIR,eAAeM,IAAI,CAACL,OAAOL,aAAa,CAAC,EAAE,OAAOA,cAAiCU;IACvF,mBAAmB,GACnB,IAAI,AAACA,KAA2BG,SAAS,EAAE,OAAOV,eAAkC,AAACO,KAA2BG,SAAS;IACzH,IAAI,AAACH,KAAcI,MAAM,EAAE,OAAOX,eAAkC,AAAC,AAACO,KAAcI,MAAM,GAAoCD,SAAS;IACvI,IAAI,AAACH,KAAcK,WAAW,EAAE,OAAOb,gBAAmC,AAACQ,KAAcK,WAAW;IACpG,IAAI,AAACL,KAA4BM,IAAI,EAAE,OAAOf,mBAAsCS;IACpF,kBAAkB,GAElB,MAAM,IAAID,MAAM;AAClB"}