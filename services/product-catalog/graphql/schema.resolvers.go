package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"
	"time"
	"unified-commerce/services/product-catalog/models"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

// ID is the resolver for the id field.
func (r *brandResolver) ID(ctx context.Context, obj *models.Brand) (string, error) {
	return obj.ID.Hex(), nil
}

// Handle is the resolver for the handle field.
func (r *brandResolver) Handle(ctx context.Context, obj *models.Brand) (string, error) {
	return obj.Slug, nil
}

// Logo is the resolver for the logo field.
func (r *brandResolver) Logo(ctx context.Context, obj *models.Brand) (*string, error) {
	if obj.Logo != nil {
		url := obj.Logo.URL
		return &url, nil
	}
	return nil, nil
}

// SeoTitle is the resolver for the seoTitle field.
func (r *brandResolver) SeoTitle(ctx context.Context, obj *models.Brand) (*string, error) {
	title := obj.SEO.Title
	return &title, nil
}

// SeoDescription is the resolver for the seoDescription field.
func (r *brandResolver) SeoDescription(ctx context.Context, obj *models.Brand) (*string, error) {
	description := obj.SEO.Description
	return &description, nil
}

// Metafields is the resolver for the metafields field.
func (r *brandResolver) Metafields(ctx context.Context, obj *models.Brand) (*string, error) {
	// Not implemented for now
	return nil, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *brandResolver) CreatedAt(ctx context.Context, obj *models.Brand) (string, error) {
	return obj.CreatedAt.String(), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *brandResolver) UpdatedAt(ctx context.Context, obj *models.Brand) (*string, error) {
	updatedAt := obj.UpdatedAt.String()
	return &updatedAt, nil
}

// Products is the resolver for the products field.
func (r *brandResolver) Products(ctx context.Context, obj *models.Brand) ([]*models.Product, error) {
	// Return empty array for now
	return []*models.Product{}, nil
}

// ID is the resolver for the id field.
func (r *categoryResolver) ID(ctx context.Context, obj *models.Category) (string, error) {
	return obj.ID.Hex(), nil
}

// Handle is the resolver for the handle field.
func (r *categoryResolver) Handle(ctx context.Context, obj *models.Category) (string, error) {
	return obj.Slug, nil
}

// SeoTitle is the resolver for the seoTitle field.
func (r *categoryResolver) SeoTitle(ctx context.Context, obj *models.Category) (*string, error) {
	title := obj.SEO.Title
	return &title, nil
}

// SeoDescription is the resolver for the seoDescription field.
func (r *categoryResolver) SeoDescription(ctx context.Context, obj *models.Category) (*string, error) {
	description := obj.SEO.Description
	return &description, nil
}

// IsVisible is the resolver for the isVisible field.
func (r *categoryResolver) IsVisible(ctx context.Context, obj *models.Category) (bool, error) {
	return obj.IsActive, nil
}

// Image is the resolver for the image field.
func (r *categoryResolver) Image(ctx context.Context, obj *models.Category) (*string, error) {
	if obj.Image != nil {
		url := obj.Image.URL
		return &url, nil
	}
	return nil, nil
}

// Metafields is the resolver for the metafields field.
func (r *categoryResolver) Metafields(ctx context.Context, obj *models.Category) (*string, error) {
	// Not implemented for now
	return nil, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *categoryResolver) CreatedAt(ctx context.Context, obj *models.Category) (string, error) {
	return obj.CreatedAt.String(), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *categoryResolver) UpdatedAt(ctx context.Context, obj *models.Category) (*string, error) {
	updatedAt := obj.UpdatedAt.String()
	return &updatedAt, nil
}

// Parent is the resolver for the parent field.
func (r *categoryResolver) Parent(ctx context.Context, obj *models.Category) (*models.Category, error) {
	if obj.ParentID == "" {
		return nil, nil // No parent
	}

	// Get the parent category from the service
	parent, err := r.ProductService.GetCategoryParent(ctx, obj.ParentID)
	if err != nil {
		return nil, err
	}

	return parent, nil
}

// Children is the resolver for the children field.
func (r *categoryResolver) Children(ctx context.Context, obj *models.Category) ([]*models.Category, error) {
	// Get the child categories from the service
	children, err := r.ProductService.GetCategoryChildren(ctx, obj.ID.Hex())
	if err != nil {
		return nil, err
	}

	// Convert to pointer array
	childrenPtr := make([]*models.Category, len(children))
	for i := range children {
		childrenPtr[i] = &children[i]
	}

	return childrenPtr, nil
}

// Products is the resolver for the products field.
func (r *categoryResolver) Products(ctx context.Context, obj *models.Category) ([]*models.Product, error) {
	// Return empty array for now
	return []*models.Product{}, nil
}

// ID is the resolver for the id field.
func (r *collectionResolver) ID(ctx context.Context, obj *models.Collection) (string, error) {
	return obj.ID.Hex(), nil
}

// Title is the resolver for the title field.
func (r *collectionResolver) Title(ctx context.Context, obj *models.Collection) (string, error) {
	return obj.Name, nil
}

// Handle is the resolver for the handle field.
func (r *collectionResolver) Handle(ctx context.Context, obj *models.Collection) (string, error) {
	return obj.Slug, nil
}

// SeoTitle is the resolver for the seoTitle field.
func (r *collectionResolver) SeoTitle(ctx context.Context, obj *models.Collection) (*string, error) {
	title := obj.SEO.Title
	return &title, nil
}

// SeoDescription is the resolver for the seoDescription field.
func (r *collectionResolver) SeoDescription(ctx context.Context, obj *models.Collection) (*string, error) {
	description := obj.SEO.Description
	return &description, nil
}

// SortOrder is the resolver for the sortOrder field.
func (r *collectionResolver) SortOrder(ctx context.Context, obj *models.Collection) (CollectionSortOrder, error) {
	// Return default value
	return CollectionSortOrderCreatedDesc, nil
}

// IsVisible is the resolver for the isVisible field.
func (r *collectionResolver) IsVisible(ctx context.Context, obj *models.Collection) (bool, error) {
	return obj.IsActive, nil
}

// Image is the resolver for the image field.
func (r *collectionResolver) Image(ctx context.Context, obj *models.Collection) (*string, error) {
	if obj.Image != nil {
		url := obj.Image.URL
		return &url, nil
	}
	return nil, nil
}

// RulesMatch is the resolver for the rulesMatch field.
func (r *collectionResolver) RulesMatch(ctx context.Context, obj *models.Collection) (*CollectionRulesMatch, error) {
	rulesMatch := CollectionRulesMatchAll
	return &rulesMatch, nil
}

// Metafields is the resolver for the metafields field.
func (r *collectionResolver) Metafields(ctx context.Context, obj *models.Collection) (*string, error) {
	// Not implemented for now
	return nil, nil
}

// PublishedAt is the resolver for the publishedAt field.
func (r *collectionResolver) PublishedAt(ctx context.Context, obj *models.Collection) (*string, error) {
	if obj.PublishedAt != nil {
		publishedAt := obj.PublishedAt.String()
		return &publishedAt, nil
	}
	return nil, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *collectionResolver) CreatedAt(ctx context.Context, obj *models.Collection) (string, error) {
	return obj.CreatedAt.String(), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *collectionResolver) UpdatedAt(ctx context.Context, obj *models.Collection) (*string, error) {
	updatedAt := obj.UpdatedAt.String()
	return &updatedAt, nil
}

// Products is the resolver for the products field.
func (r *collectionResolver) Products(ctx context.Context, obj *models.Collection) ([]*models.Product, error) {
	// Return empty array for now
	return []*models.Product{}, nil
}

// ID is the resolver for the id field.
func (r *collectionRuleResolver) ID(ctx context.Context, obj *models.CollectionRule) (string, error) {
	return obj.Field, nil
}

// CollectionID is the resolver for the collectionId field.
func (r *collectionRuleResolver) CollectionID(ctx context.Context, obj *models.CollectionRule) (string, error) {
	return obj.Field, nil
}

// Column is the resolver for the column field.
func (r *collectionRuleResolver) Column(ctx context.Context, obj *models.CollectionRule) (string, error) {
	return obj.Field, nil
}

// Relation is the resolver for the relation field.
func (r *collectionRuleResolver) Relation(ctx context.Context, obj *models.CollectionRule) (string, error) {
	return obj.Operator, nil
}

// Condition is the resolver for the condition field.
func (r *collectionRuleResolver) Condition(ctx context.Context, obj *models.CollectionRule) (string, error) {
	// Convert value to string
	condition := fmt.Sprintf("%v", obj.Value)
	return condition, nil
}

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input CreateProductInput) (*models.Product, error) {
	// For now, return error - would need service method implementation
	return nil, fmt.Errorf("create product not implemented yet")
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, id string, input UpdateProductInput) (*models.Product, error) {
	// For now, return error - would need service method implementation
	return nil, fmt.Errorf("update product not implemented yet")
}

// DeleteProduct is the resolver for the deleteProduct field.
func (r *mutationResolver) DeleteProduct(ctx context.Context, id string) (bool, error) {
	// For now, return error - would need service method implementation
	return false, fmt.Errorf("delete product not implemented yet")
}

// PublishProduct is the resolver for the publishProduct field.
func (r *mutationResolver) PublishProduct(ctx context.Context, id string) (*models.Product, error) {
	// For now, return error - would need service method implementation
	return nil, fmt.Errorf("publish product not implemented yet")
}

// UnpublishProduct is the resolver for the unpublishProduct field.
func (r *mutationResolver) UnpublishProduct(ctx context.Context, id string) (*models.Product, error) {
	// For now, return error - would need service method implementation
	return nil, fmt.Errorf("unpublish product not implemented yet")
}

// CreateProductVariant is the resolver for the createProductVariant field.
func (r *mutationResolver) CreateProductVariant(ctx context.Context, input CreateProductVariantInput) (*models.ProductVariant, error) {
	// For now, return error - would need service method implementation
	return nil, fmt.Errorf("create product variant not implemented yet")
}

// UpdateProductVariant is the resolver for the updateProductVariant field.
func (r *mutationResolver) UpdateProductVariant(ctx context.Context, id string, input UpdateProductVariantInput) (*models.ProductVariant, error) {
	// For now, return error - would need service method implementation
	return nil, fmt.Errorf("update product variant not implemented yet")
}

// DeleteProductVariant is the resolver for the deleteProductVariant field.
func (r *mutationResolver) DeleteProductVariant(ctx context.Context, id string) (bool, error) {
	// For now, return error - would need service method implementation
	return false, fmt.Errorf("delete product variant not implemented yet")
}

// CreateCategory is the resolver for the createCategory field.
func (r *mutationResolver) CreateCategory(ctx context.Context, input CreateCategoryInput) (*models.Category, error) {
	// For now, return error - would need service method implementation
	return nil, fmt.Errorf("create category not implemented yet")
}

// UpdateCategory is the resolver for the updateCategory field.
func (r *mutationResolver) UpdateCategory(ctx context.Context, id string, input UpdateCategoryInput) (*models.Category, error) {
	// For now, return error - would need service method implementation
	return nil, fmt.Errorf("update category not implemented yet")
}

// DeleteCategory is the resolver for the deleteCategory field.
func (r *mutationResolver) DeleteCategory(ctx context.Context, id string) (bool, error) {
	// For now, return error - would need service method implementation
	return false, fmt.Errorf("delete category not implemented yet")
}

// CreateCollection is the resolver for the createCollection field.
func (r *mutationResolver) CreateCollection(ctx context.Context, input CreateCollectionInput) (*models.Collection, error) {
	// For now, return error - would need service method implementation
	return nil, fmt.Errorf("create collection not implemented yet")
}

// UpdateCollection is the resolver for the updateCollection field.
func (r *mutationResolver) UpdateCollection(ctx context.Context, id string, input UpdateCollectionInput) (*models.Collection, error) {
	// For now, return error - would need service method implementation
	return nil, fmt.Errorf("update collection not implemented yet")
}

// DeleteCollection is the resolver for the deleteCollection field.
func (r *mutationResolver) DeleteCollection(ctx context.Context, id string) (bool, error) {
	// For now, return error - would need service method implementation
	return false, fmt.Errorf("delete collection not implemented yet")
}

// AddProductToCollection is the resolver for the addProductToCollection field.
func (r *mutationResolver) AddProductToCollection(ctx context.Context, collectionID string, productID string) (*models.Collection, error) {
	// For now, return error - would need service method implementation
	return nil, fmt.Errorf("add product to collection not implemented yet")
}

// RemoveProductFromCollection is the resolver for the removeProductFromCollection field.
func (r *mutationResolver) RemoveProductFromCollection(ctx context.Context, collectionID string, productID string) (*models.Collection, error) {
	// For now, return error - would need service method implementation
	return nil, fmt.Errorf("remove product from collection not implemented yet")
}

// CreateBrand is the resolver for the createBrand field.
func (r *mutationResolver) CreateBrand(ctx context.Context, input CreateBrandInput) (*models.Brand, error) {
	// For now, return error - would need service method implementation
	return nil, fmt.Errorf("create brand not implemented yet")
}

// UpdateBrand is the resolver for the updateBrand field.
func (r *mutationResolver) UpdateBrand(ctx context.Context, id string, input UpdateBrandInput) (*models.Brand, error) {
	// For now, return error - would need service method implementation
	return nil, fmt.Errorf("update brand not implemented yet")
}

// DeleteBrand is the resolver for the deleteBrand field.
func (r *mutationResolver) DeleteBrand(ctx context.Context, id string) (bool, error) {
	// For now, return error - would need service method implementation
	return false, fmt.Errorf("delete brand not implemented yet")
}

// ID is the resolver for the id field.
func (r *productResolver) ID(ctx context.Context, obj *models.Product) (string, error) {
	return obj.ID.Hex(), nil
}

// Title is the resolver for the title field.
func (r *productResolver) Title(ctx context.Context, obj *models.Product) (string, error) {
	return obj.Name, nil
}

// Handle is the resolver for the handle field.
func (r *productResolver) Handle(ctx context.Context, obj *models.Product) (string, error) {
	return obj.Slug, nil
}

// Vendor is the resolver for the vendor field.
func (r *productResolver) Vendor(ctx context.Context, obj *models.Product) (*string, error) {
	// Not implemented for now
	return nil, nil
}

// ProductType is the resolver for the productType field.
func (r *productResolver) ProductType(ctx context.Context, obj *models.Product) (*string, error) {
	productType := obj.Type
	return &productType, nil
}

// Status is the resolver for the status field.
func (r *productResolver) Status(ctx context.Context, obj *models.Product) (ProductStatus, error) {
	// Map product status to GraphQL enum
	switch obj.Status {
	case "active":
		return ProductStatusActive, nil
	case "archived":
		return ProductStatusArchived, nil
	case "draft":
		return ProductStatusDraft, nil
	default:
		return ProductStatusActive, nil
	}
}

// SeoTitle is the resolver for the seoTitle field.
func (r *productResolver) SeoTitle(ctx context.Context, obj *models.Product) (*string, error) {
	title := obj.SEO.Title
	return &title, nil
}

// SeoDescription is the resolver for the seoDescription field.
func (r *productResolver) SeoDescription(ctx context.Context, obj *models.Product) (*string, error) {
	description := obj.SEO.Description
	return &description, nil
}

// PublishedAt is the resolver for the publishedAt field.
func (r *productResolver) PublishedAt(ctx context.Context, obj *models.Product) (*string, error) {
	if obj.PublishedAt != nil {
		publishedAt := obj.PublishedAt.String()
		return &publishedAt, nil
	}
	return nil, nil
}

// PublishedScope is the resolver for the publishedScope field.
func (r *productResolver) PublishedScope(ctx context.Context, obj *models.Product) (PublishedScope, error) {
	// Return default value
	return PublishedScopeGlobal, nil
}

// FeaturedImage is the resolver for the featuredImage field.
func (r *productResolver) FeaturedImage(ctx context.Context, obj *models.Product) (*string, error) {
	// Get primary image if available
	if primaryImage := obj.GetPrimaryImage(); primaryImage != nil {
		url := primaryImage.URL
		return &url, nil
	}
	return nil, nil
}

// PriceRange is the resolver for the priceRange field.
func (r *productResolver) PriceRange(ctx context.Context, obj *models.Product) (*models.ProductPriceRange, error) {
	// Return a simple price range based on product price
	return &models.ProductPriceRange{
		MinVariantPrice: obj.Price,
		MaxVariantPrice: obj.Price,
	}, nil
}

// CompareAtPriceRange is the resolver for the compareAtPriceRange field.
func (r *productResolver) CompareAtPriceRange(ctx context.Context, obj *models.Product) (*models.ProductPriceRange, error) {
	// Return compare at price range if available
	if obj.CompareAtPrice > 0 {
		return &models.ProductPriceRange{
			MinVariantPrice: obj.CompareAtPrice,
			MaxVariantPrice: obj.CompareAtPrice,
		}, nil
	}
	return nil, nil
}

// TotalInventory is the resolver for the totalInventory field.
func (r *productResolver) TotalInventory(ctx context.Context, obj *models.Product) (int, error) {
	// Return a default value for now
	return 100, nil
}

// HasOnlyDefaultVariant is the resolver for the hasOnlyDefaultVariant field.
func (r *productResolver) HasOnlyDefaultVariant(ctx context.Context, obj *models.Product) (bool, error) {
	// Return true if product has only one variant or no variants
	return len(obj.Variants) <= 1, nil
}

// RequiresSellingPlan is the resolver for the requiresSellingPlan field.
func (r *productResolver) RequiresSellingPlan(ctx context.Context, obj *models.Product) (bool, error) {
	// Return false for now
	return false, nil
}

// Metafields is the resolver for the metafields field.
func (r *productResolver) Metafields(ctx context.Context, obj *models.Product) (*string, error) {
	// Not implemented for now
	return nil, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *productResolver) CreatedAt(ctx context.Context, obj *models.Product) (string, error) {
	return obj.CreatedAt.String(), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *productResolver) UpdatedAt(ctx context.Context, obj *models.Product) (*string, error) {
	updatedAt := obj.UpdatedAt.String()
	return &updatedAt, nil
}

// Collections is the resolver for the collections field.
func (r *productResolver) Collections(ctx context.Context, obj *models.Product) ([]*models.Collection, error) {
	// Return empty array for now
	return []*models.Collection{}, nil
}

// Category is the resolver for the category field.
func (r *productResolver) Category(ctx context.Context, obj *models.Product) (*models.Category, error) {
	// Return nil for now
	return nil, nil
}

// Brand is the resolver for the brand field.
func (r *productResolver) Brand(ctx context.Context, obj *models.Product) (*models.Brand, error) {
	// Return nil for now
	return nil, nil
}

// ProductID is the resolver for the productId field.
func (r *productImageResolver) ProductID(ctx context.Context, obj *models.ProductImage) (*string, error) {
	// Not implemented for now
	return nil, nil
}

// VariantIds is the resolver for the variantIds field.
func (r *productImageResolver) VariantIds(ctx context.Context, obj *models.ProductImage) ([]string, error) {
	// Return empty array for now
	return []string{}, nil
}

// Src is the resolver for the src field.
func (r *productImageResolver) Src(ctx context.Context, obj *models.ProductImage) (string, error) {
	return obj.URL, nil
}

// AltText is the resolver for the altText field.
func (r *productImageResolver) AltText(ctx context.Context, obj *models.ProductImage) (*string, error) {
	alt := obj.Alt
	return &alt, nil
}

// Position is the resolver for the position field.
func (r *productImageResolver) Position(ctx context.Context, obj *models.ProductImage) (int, error) {
	return obj.SortOrder, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *productImageResolver) CreatedAt(ctx context.Context, obj *models.ProductImage) (string, error) {
	return obj.CreatedAt.String(), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *productImageResolver) UpdatedAt(ctx context.Context, obj *models.ProductImage) (*string, error) {
	updatedAt := obj.CreatedAt.String()
	return &updatedAt, nil
}

// ProductID is the resolver for the productId field.
func (r *productOptionResolver) ProductID(ctx context.Context, obj *models.ProductOption) (string, error) {
	return obj.ID, nil
}

// ProductID is the resolver for the productId field.
func (r *productVariantResolver) ProductID(ctx context.Context, obj *models.ProductVariant) (string, error) {
	return obj.ID, nil
}

// Title is the resolver for the title field.
func (r *productVariantResolver) Title(ctx context.Context, obj *models.ProductVariant) (string, error) {
	// For now, return SKU as title
	return obj.SKU, nil
}

// InventoryQuantity is the resolver for the inventoryQuantity field.
func (r *productVariantResolver) InventoryQuantity(ctx context.Context, obj *models.ProductVariant) (int, error) {
	// Return a default value for now
	return 100, nil
}

// InventoryPolicy is the resolver for the inventoryPolicy field.
func (r *productVariantResolver) InventoryPolicy(ctx context.Context, obj *models.ProductVariant) (InventoryPolicy, error) {
	// Return default value
	return InventoryPolicyDeny, nil
}

// FulfillmentService is the resolver for the fulfillmentService field.
func (r *productVariantResolver) FulfillmentService(ctx context.Context, obj *models.ProductVariant) (*string, error) {
	// Not implemented for now
	return nil, nil
}

// InventoryManagement is the resolver for the inventoryManagement field.
func (r *productVariantResolver) InventoryManagement(ctx context.Context, obj *models.ProductVariant) (*string, error) {
	// Not implemented for now
	return nil, nil
}

// WeightUnit is the resolver for the weightUnit field.
func (r *productVariantResolver) WeightUnit(ctx context.Context, obj *models.ProductVariant) (*string, error) {
	// Not implemented for now
	return nil, nil
}

// RequiresShipping is the resolver for the requiresShipping field.
func (r *productVariantResolver) RequiresShipping(ctx context.Context, obj *models.ProductVariant) (bool, error) {
	// Return default value
	return true, nil
}

// Taxable is the resolver for the taxable field.
func (r *productVariantResolver) Taxable(ctx context.Context, obj *models.ProductVariant) (bool, error) {
	// Return default value
	return true, nil
}

// TaxCode is the resolver for the taxCode field.
func (r *productVariantResolver) TaxCode(ctx context.Context, obj *models.ProductVariant) (*string, error) {
	// Not implemented for now
	return nil, nil
}

// Option1 is the resolver for the option1 field.
func (r *productVariantResolver) Option1(ctx context.Context, obj *models.ProductVariant) (*string, error) {
	// Not implemented for now
	return nil, nil
}

// Option2 is the resolver for the option2 field.
func (r *productVariantResolver) Option2(ctx context.Context, obj *models.ProductVariant) (*string, error) {
	// Not implemented for now
	return nil, nil
}

// Option3 is the resolver for the option3 field.
func (r *productVariantResolver) Option3(ctx context.Context, obj *models.ProductVariant) (*string, error) {
	// Not implemented for now
	return nil, nil
}

// Metafields is the resolver for the metafields field.
func (r *productVariantResolver) Metafields(ctx context.Context, obj *models.ProductVariant) (*string, error) {
	// Not implemented for now
	return nil, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *productVariantResolver) CreatedAt(ctx context.Context, obj *models.ProductVariant) (string, error) {
	return obj.CreatedAt.String(), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *productVariantResolver) UpdatedAt(ctx context.Context, obj *models.ProductVariant) (*string, error) {
	updatedAt := obj.UpdatedAt.String()
	return &updatedAt, nil
}

// Product is the resolver for the product field.
func (r *productVariantResolver) Product(ctx context.Context, obj *models.ProductVariant) (*models.Product, error) {
	// Create a mock ObjectID for the product
	objectID := primitive.NewObjectID()
	return &models.Product{
		ID:          objectID,
		MerchantID:  "merchant-123",
		Name:        "Sample Product",
		Description: "This is a sample product",
		Price:       obj.Price,
	}, nil
}

// Product is the resolver for the product field.
func (r *queryResolver) Product(ctx context.Context, id string) (*models.Product, error) {
	// Create a mock ObjectID for the product
	objectID, _ := primitive.ObjectIDFromHex(id)

	// Parse the time
	createdAt, _ := time.Parse(time.RFC3339, "2023-01-01T00:00:00Z")

	return &models.Product{
		ID:          objectID,
		MerchantID:  "merchant-123",
		Name:        "Sample Product",
		Description: "This is a sample product for testing GraphQL resolvers",
		Price:       29.99,
		Status:      "active",
		Type:        "simple",
		Slug:        "sample-product",
		CreatedAt:   createdAt,
	}, nil
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context, filter *ProductFilter) ([]*models.Product, error) {
	// Create mock ObjectIDs for the products
	objectID1 := primitive.NewObjectID()
	objectID2 := primitive.NewObjectID()
	objectID3 := primitive.NewObjectID()

	// Parse the times
	createdAt1, _ := time.Parse(time.RFC3339, "2023-01-01T00:00:00Z")
	createdAt2, _ := time.Parse(time.RFC3339, "2023-01-02T00:00:00Z")
	createdAt3, _ := time.Parse(time.RFC3339, "2023-01-03T00:00:00Z")

	// Return a few mock products for now
	products := []*models.Product{
		{
			ID:          objectID1,
			MerchantID:  "merchant-123",
			Name:        "Sample Product 1",
			Description: "This is the first sample product for testing GraphQL resolvers",
			Price:       29.99,
			Status:      "active",
			Type:        "simple",
			Slug:        "sample-product-1",
			CreatedAt:   createdAt1,
		},
		{
			ID:          objectID2,
			MerchantID:  "merchant-123",
			Name:        "Sample Product 2",
			Description: "This is the second sample product for testing GraphQL resolvers",
			Price:       39.99,
			Status:      "active",
			Type:        "simple",
			Slug:        "sample-product-2",
			CreatedAt:   createdAt2,
		},
		{
			ID:          objectID3,
			MerchantID:  "merchant-123",
			Name:        "Sample Product 3",
			Description: "This is the third sample product for testing GraphQL resolvers",
			Price:       49.99,
			Status:      "active",
			Type:        "simple",
			Slug:        "sample-product-3",
			CreatedAt:   createdAt3,
		},
	}
	return products, nil
}

// ProductByHandle is the resolver for the productByHandle field.
func (r *queryResolver) ProductByHandle(ctx context.Context, handle string) (*models.Product, error) {
	// Create a mock ObjectID for the product
	objectID := primitive.NewObjectID()

	// Parse the time
	createdAt, _ := time.Parse(time.RFC3339, "2023-01-01T00:00:00Z")

	return &models.Product{
		ID:          objectID,
		MerchantID:  "merchant-123",
		Name:        "Sample Product",
		Description: "This is a sample product for testing GraphQL resolvers",
		Price:       29.99,
		Status:      "active",
		Type:        "simple",
		Slug:        handle,
		CreatedAt:   createdAt,
	}, nil
}

// ProductsBySku is the resolver for the productsBySku field.
func (r *queryResolver) ProductsBySku(ctx context.Context, skus []string) ([]*models.Product, error) {
	// Return empty array for now
	return []*models.Product{}, nil
}

// SearchSuggestions is the resolver for the searchSuggestions field.
func (r *queryResolver) SearchSuggestions(ctx context.Context, query string, limit *int) ([]*models.SearchSuggestion, error) {
	// Set default limit
	limitValue := 10
	if limit != nil && *limit > 0 {
		limitValue = *limit
	}

	// Create a slice to hold our suggestions
	suggestions := make([]*models.SearchSuggestion, 0)

	// Search for products
	productFilter := &ProductFilter{
		Search: &query,
		Limit:  &limitValue,
	}

	products, err := r.Products(ctx, productFilter)
	if err != nil {
		return nil, err
	}

	// Add product suggestions
	for _, product := range products {
		if len(suggestions) >= limitValue {
			break
		}

		suggestion := &models.SearchSuggestion{
			ID:    product.ID.Hex(),
			Title: product.Name,
			Type:  "PRODUCT",
		}

		// Add image URL if available
		if len(product.Images) > 0 {
			suggestion.ImageURL = &product.Images[0].URL
		}

		suggestions = append(suggestions, suggestion)
	}

	// If we haven't reached the limit, search for categories
	if len(suggestions) < limitValue {
		categoryLimit := limitValue - len(suggestions)
		categoryFilter := &CategoryFilter{
			Limit: &categoryLimit,
		}

		categories, err := r.Categories(ctx, categoryFilter)
		if err != nil {
			return suggestions, nil // Return what we have
		}

		// Add category suggestions
		for _, category := range categories {
			if len(suggestions) >= limitValue {
				break
			}

			suggestion := &models.SearchSuggestion{
				ID:    category.ID.Hex(),
				Title: category.Name,
				Type:  "CATEGORY",
			}

			suggestions = append(suggestions, suggestion)
		}
	}

	// If we haven't reached the limit, search for brands
	if len(suggestions) < limitValue {
		var merchantID *string
		brands, err := r.Brands(ctx, merchantID)
		if err != nil {
			return suggestions, nil // Return what we have
		}

		// Add brand suggestions
		for _, brand := range brands {
			if len(suggestions) >= limitValue {
				break
			}

			suggestion := &models.SearchSuggestion{
				ID:    brand.ID.Hex(),
				Title: brand.Name,
				Type:  "BRAND",
			}

			// Add image URL if available
			if brand.Logo != nil {
				suggestion.ImageURL = &brand.Logo.URL
			}

			suggestions = append(suggestions, suggestion)
		}
	}

	return suggestions, nil
}

// ProductVariant is the resolver for the productVariant field.
func (r *queryResolver) ProductVariant(ctx context.Context, id string) (*models.ProductVariant, error) {
	// Return a mock product variant for now
	return &models.ProductVariant{
		ID:    id,
		SKU:   "SAMPLE-SKU-123",
		Price: 29.99,
	}, nil
}

// ProductVariants is the resolver for the productVariants field.
func (r *queryResolver) ProductVariants(ctx context.Context, productID string) ([]*models.ProductVariant, error) {
	// Return empty array for now
	return []*models.ProductVariant{}, nil
}

// Category is the resolver for the category field.
func (r *queryResolver) Category(ctx context.Context, id string) (*models.Category, error) {
	// Create a mock ObjectID for the category
	objectID, _ := primitive.ObjectIDFromHex(id)
	return &models.Category{
		ID:         objectID,
		MerchantID: "merchant-123",
		Name:       "Sample Category",
		Slug:       "sample-category",
	}, nil
}

// Categories is the resolver for the categories field.
func (r *queryResolver) Categories(ctx context.Context, filter *CategoryFilter) ([]*models.Category, error) {
	// Create mock ObjectIDs for the categories
	objectID1 := primitive.NewObjectID()
	objectID2 := primitive.NewObjectID()
	objectID3 := primitive.NewObjectID()

	// Parse the time
	createdAt, _ := time.Parse(time.RFC3339, "2023-01-01T00:00:00Z")

	// Return a few mock categories for now
	categories := []*models.Category{
		{
			ID:         objectID1,
			MerchantID: "merchant-123",
			Name:       "Electronics",
			Slug:       "electronics",
			CreatedAt:  createdAt,
		},
		{
			ID:         objectID2,
			MerchantID: "merchant-123",
			Name:       "Clothing",
			Slug:       "clothing",
			CreatedAt:  createdAt,
		},
		{
			ID:         objectID3,
			MerchantID: "merchant-123",
			Name:       "Home & Garden",
			Slug:       "home-garden",
			CreatedAt:  createdAt,
		},
	}
	return categories, nil
}

// Collection is the resolver for the collection field.
func (r *queryResolver) Collection(ctx context.Context, id string) (*models.Collection, error) {
	// Create a mock ObjectID for the collection
	objectID, _ := primitive.ObjectIDFromHex(id)

	// Parse the time
	createdAt, _ := time.Parse(time.RFC3339, "2023-01-01T00:00:00Z")

	return &models.Collection{
		ID:         objectID,
		MerchantID: "merchant-123",
		Name:       "Sample Collection",
		Slug:       "sample-collection",
		CreatedAt:  createdAt,
	}, nil
}

// Collections is the resolver for the collections field.
func (r *queryResolver) Collections(ctx context.Context, filter *CollectionFilter) ([]*models.Collection, error) {
	// Create mock ObjectIDs for the collections
	objectID1 := primitive.NewObjectID()
	objectID2 := primitive.NewObjectID()

	// Parse the time
	createdAt, _ := time.Parse(time.RFC3339, "2023-01-01T00:00:00Z")

	// Return a few mock collections for now
	collections := []*models.Collection{
		{
			ID:         objectID1,
			MerchantID: "merchant-123",
			Name:       "Summer Collection",
			Slug:       "summer-collection",
			CreatedAt:  createdAt,
		},
		{
			ID:         objectID2,
			MerchantID: "merchant-123",
			Name:       "Winter Collection",
			Slug:       "winter-collection",
			CreatedAt:  createdAt,
		},
	}
	return collections, nil
}

// Brand is the resolver for the brand field.
func (r *queryResolver) Brand(ctx context.Context, id string) (*models.Brand, error) {
	// Create a mock ObjectID for the brand
	objectID, _ := primitive.ObjectIDFromHex(id)

	// Parse the time
	createdAt, _ := time.Parse(time.RFC3339, "2023-01-01T00:00:00Z")

	return &models.Brand{
		ID:         objectID,
		MerchantID: "merchant-123",
		Name:       "Sample Brand",
		Slug:       "sample-brand",
		CreatedAt:  createdAt,
	}, nil
}

// Brands is the resolver for the brands field.
func (r *queryResolver) Brands(ctx context.Context, merchantID *string) ([]*models.Brand, error) {
	// Create mock ObjectIDs for the brands
	objectID1 := primitive.NewObjectID()
	objectID2 := primitive.NewObjectID()
	objectID3 := primitive.NewObjectID()

	// Parse the time
	createdAt, _ := time.Parse(time.RFC3339, "2023-01-01T00:00:00Z")

	// Return a few mock brands for now
	brands := []*models.Brand{
		{
			ID:         objectID1,
			MerchantID: "merchant-123",
			Name:       "Nike",
			Slug:       "nike",
			CreatedAt:  createdAt,
		},
		{
			ID:         objectID2,
			MerchantID: "merchant-123",
			Name:       "Adidas",
			Slug:       "adidas",
			CreatedAt:  createdAt,
		},
		{
			ID:         objectID3,
			MerchantID: "merchant-123",
			Name:       "Apple",
			Slug:       "apple",
			CreatedAt:  createdAt,
		},
	}
	return brands, nil
}

// Type is the resolver for the type field.
func (r *searchSuggestionResolver) Type(ctx context.Context, obj *models.SearchSuggestion) (SearchSuggestionType, error) {
	// Convert the string type to the enum
	switch obj.Type {
	case "PRODUCT":
		return SearchSuggestionTypeProduct, nil
	case "CATEGORY":
		return SearchSuggestionTypeCategory, nil
	case "BRAND":
		return SearchSuggestionTypeBrand, nil
	default:
		return SearchSuggestionTypeProduct, nil
	}
}

// Brand returns BrandResolver implementation.
func (r *Resolver) Brand() BrandResolver { return &brandResolver{r} }

// Category returns CategoryResolver implementation.
func (r *Resolver) Category() CategoryResolver { return &categoryResolver{r} }

// Collection returns CollectionResolver implementation.
func (r *Resolver) Collection() CollectionResolver { return &collectionResolver{r} }

// CollectionRule returns CollectionRuleResolver implementation.
func (r *Resolver) CollectionRule() CollectionRuleResolver { return &collectionRuleResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Product returns ProductResolver implementation.
func (r *Resolver) Product() ProductResolver { return &productResolver{r} }

// ProductImage returns ProductImageResolver implementation.
func (r *Resolver) ProductImage() ProductImageResolver { return &productImageResolver{r} }

// ProductOption returns ProductOptionResolver implementation.
func (r *Resolver) ProductOption() ProductOptionResolver { return &productOptionResolver{r} }

// ProductVariant returns ProductVariantResolver implementation.
func (r *Resolver) ProductVariant() ProductVariantResolver { return &productVariantResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// SearchSuggestion returns SearchSuggestionResolver implementation.
func (r *Resolver) SearchSuggestion() SearchSuggestionResolver { return &searchSuggestionResolver{r} }

type brandResolver struct{ *Resolver }
type categoryResolver struct{ *Resolver }
type collectionResolver struct{ *Resolver }
type collectionRuleResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type productResolver struct{ *Resolver }
type productImageResolver struct{ *Resolver }
type productOptionResolver struct{ *Resolver }
type productVariantResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type searchSuggestionResolver struct{ *Resolver }
