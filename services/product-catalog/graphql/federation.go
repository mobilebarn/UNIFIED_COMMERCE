// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"context"
	"errors"
	"strings"

	"github.com/99designs/gqlgen/plugin/federation/fedruntime"
)

var (
	ErrUnknownType  = errors.New("unknown type")
	ErrTypeNotFound = errors.New("type not found")
)

func (ec *executionContext) __resolve__service(ctx context.Context) (fedruntime.Service, error) {
	if ec.DisableIntrospection {
		return fedruntime.Service{}, errors.New("federated introspection disabled")
	}

	var sdl []string

	for _, src := range sources {
		if src.BuiltIn {
			continue
		}
		sdl = append(sdl, src.Input)
	}

	return fedruntime.Service{
		SDL: strings.Join(sdl, "\n"),
	}, nil
}

func (ec *executionContext) __resolve_entities(ctx context.Context, representations []map[string]interface{}) ([]fedruntime.Entity, error) {
	list := []fedruntime.Entity{}
	for _, repr := range representations {
		typeName := repr["__typename"].(string)
		switch typeName {
		case "Product":
			id := repr["id"].(string)
			entity := ec.resolveProductByKey(ctx, id)
			if entity == nil {
				return nil, errors.New("entity not found")
			}
			list = append(list, entity)
		case "ProductVariant":
			id := repr["id"].(string)
			entity := ec.resolveProductVariantByKey(ctx, id)
			if entity == nil {
				return nil, errors.New("entity not found")
			}
			list = append(list, entity)
		case "Category":
			id := repr["id"].(string)
			entity := ec.resolveCategoryByKey(ctx, id)
			if entity == nil {
				return nil, errors.New("entity not found")
			}
			list = append(list, entity)
		case "Collection":
			id := repr["id"].(string)
			entity := ec.resolveCollectionByKey(ctx, id)
			if entity == nil {
				return nil, errors.New("entity not found")
			}
			list = append(list, entity)
		case "Brand":
			id := repr["id"].(string)
			entity := ec.resolveBrandByKey(ctx, id)
			if entity == nil {
				return nil, errors.New("entity not found")
			}
			list = append(list, entity)
		default:
			return nil, errors.New("unknown entity type")
		}
	}
	return list, nil
}

// Entity resolver functions - these would need to be implemented based on your resolvers
func (ec *executionContext) resolveProductByKey(ctx context.Context, id string) interface{} {
	// This should call your actual product resolver
	return nil // Placeholder
}

func (ec *executionContext) resolveProductVariantByKey(ctx context.Context, id string) interface{} {
	// This should call your actual product variant resolver
	return nil // Placeholder
}

func (ec *executionContext) resolveCategoryByKey(ctx context.Context, id string) interface{} {
	// This should call your actual category resolver
	return nil // Placeholder
}

func (ec *executionContext) resolveCollectionByKey(ctx context.Context, id string) interface{} {
	// This should call your actual collection resolver
	return nil // Placeholder
}

func (ec *executionContext) resolveBrandByKey(ctx context.Context, id string) interface{} {
	// This should call your actual brand resolver
	return nil // Placeholder
}

func entityResolverNameForBrand(ctx context.Context, rep map[string]interface{}) (string, error) {
	for {
		var (
			m   map[string]interface{}
			val interface{}
			ok  bool
		)
		_ = val
		m = rep
		if _, ok = m["id"]; !ok {
			break
		}
		return "findBrandByID", nil
	}
	return "", fmt.Errorf("%w for Brand", ErrTypeNotFound)
}

func entityResolverNameForCategory(ctx context.Context, rep map[string]interface{}) (string, error) {
	for {
		var (
			m   map[string]interface{}
			val interface{}
			ok  bool
		)
		_ = val
		m = rep
		if _, ok = m["id"]; !ok {
			break
		}
		return "findCategoryByID", nil
	}
	return "", fmt.Errorf("%w for Category", ErrTypeNotFound)
}

func entityResolverNameForCollection(ctx context.Context, rep map[string]interface{}) (string, error) {
	for {
		var (
			m   map[string]interface{}
			val interface{}
			ok  bool
		)
		_ = val
		m = rep
		if _, ok = m["id"]; !ok {
			break
		}
		return "findCollectionByID", nil
	}
	return "", fmt.Errorf("%w for Collection", ErrTypeNotFound)
}

func entityResolverNameForProduct(ctx context.Context, rep map[string]interface{}) (string, error) {
	for {
		var (
			m   map[string]interface{}
			val interface{}
			ok  bool
		)
		_ = val
		m = rep
		if _, ok = m["id"]; !ok {
			break
		}
		return "findProductByID", nil
	}
	return "", fmt.Errorf("%w for Product", ErrTypeNotFound)
}

func entityResolverNameForProductVariant(ctx context.Context, rep map[string]interface{}) (string, error) {
	for {
		var (
			m   map[string]interface{}
			val interface{}
			ok  bool
		)
		_ = val
		m = rep
		if _, ok = m["id"]; !ok {
			break
		}
		return "findProductVariantByID", nil
	}
	return "", fmt.Errorf("%w for ProductVariant", ErrTypeNotFound)
}
