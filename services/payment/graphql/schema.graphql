# Federation directives
extend schema @link(url: "https://specs.apollo.dev/federation/v2.0", import: ["@key", "@external", "@requires", "@provides", "@shareable"])

directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
directive @goField(forceResolver: Boolean, name: String) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

extend type User @key(fields: "id") {
  id: ID! @external
}

extend type Order @key(fields: "id") {
  id: ID! @external
}

type Query {
  # Payment queries
  payment(id: ID!): Payment
  payments(filter: PaymentFilter): [Payment!]!
  paymentMethod(id: ID!): PaymentMethod
  paymentMethods(customerId: ID): [PaymentMethod!]!
}

type Mutation {
  # Payment mutations
  createPayment(input: CreatePaymentInput!): Payment!
  capturePaymentTransaction(id: ID!, amount: Float): Payment!
  refundPayment(id: ID!, input: RefundPaymentInput!): Payment!
  voidPayment(id: ID!): Payment!
  
  # Payment method mutations
  createPaymentMethod(input: CreatePaymentMethodInput!): PaymentMethod!
  updatePaymentMethod(id: ID!, input: UpdatePaymentMethodInput!): PaymentMethod!
  deletePaymentMethod(id: ID!): Boolean!
  setDefaultPaymentMethod(id: ID!, customerId: ID!): PaymentMethod!
}

# Main Payment type with federation key
type Payment @key(fields: "id") @goModel(model: "unified-commerce/services/payment/models.Payment") @shareable {
  id: ID!
  orderId: ID
  customerId: ID
  merchantId: ID!
  amount: Float!
  currency: String!
  status: PaymentStatus!
  gateway: String!
  gatewayTransactionId: String
  
  # Payment Method
  paymentMethodId: String
  paymentMethodType: PaymentMethodType!
  
  # Billing Information
  billingAddress: Address
  
  # Processing Information
  processorResponse: String
  failureReason: String
  
  # Metadata
  metadata: JSON
  description: String
  
  # Timestamps
  authorizedAt: String
  capturedAt: String
  failedAt: String
  refundedAt: String
  voidedAt: String
  createdAt: String!
  updatedAt: String
  
  # Relationships
  refunds: [Refund!]!
  
  # Federation relationships
  order: Order
  customer: User
}

type PaymentMethod @key(fields: "id") @goModel(model: "unified-commerce/services/payment/models.PaymentMethod") {
  id: ID!
  customerId: ID!
  merchantId: ID!
  type: PaymentMethodType!
  isDefault: Boolean!
  
  # Card Information (if applicable)
  cardLast4: String
  cardBrand: String
  cardExpMonth: Int
  cardExpYear: Int
  cardFingerprint: String
  
  # Bank Account Information (if applicable)
  bankLast4: String
  bankName: String
  bankAccountType: String
  
  # Digital Wallet Information (if applicable)
  walletType: String
  walletEmail: String
  
  # Billing Information
  billingAddress: Address
  
  # Metadata
  metadata: JSON
  
  # Timestamps
  createdAt: String!
  updatedAt: String
  
  # Federation relationships
  customer: User
}

type Refund @key(fields: "id") @goModel(model: "unified-commerce/services/payment/models.Refund") @shareable {
  id: ID!
  paymentId: ID!
  orderId: ID
  amount: Float!
  currency: String!
  status: RefundStatus!
  reason: String
  
  # Processing Information
  gatewayRefundId: String
  processorResponse: String
  failureReason: String
  
  # Metadata
  metadata: JSON
  
  # Timestamps
  processedAt: String
  createdAt: String!
  updatedAt: String
  
  # Relationships
  payment: Payment!
}

type Transaction @key(fields: "id") @goModel(model: "unified-commerce/services/payment/models.Transaction") @shareable {
  id: ID!
  paymentId: ID!
  orderId: ID
  amount: Float!
  currency: String!
  type: TransactionType!
  status: TransactionStatus!
  gateway: String!
  gatewayReference: String
  processorResponse: String
  failureReason: String
  metadata: JSON
  description: String
  processedAt: String
  createdAt: String!
  updatedAt: String
  
  # Additional fields that were missing
  kind: TransactionKind! @shareable
  paymentMethodId: String @shareable
  
  # Relationships
  payment: Payment!
}

# Extend the Address type from the inventory service
extend type Address @key(fields: "firstName lastName street1 street2 city state country postalCode") @shareable {
  firstName: String @shareable
  lastName: String @shareable
  company: String @shareable
  street1: String @shareable
  street2: String @shareable
  city: String @shareable
  state: String @shareable
  country: String @shareable
  postalCode: String @shareable
  phone: String @shareable
  latitude: Float @shareable
  longitude: Float @shareable
  timezone: String @shareable
}

# Enums
enum PaymentStatus {
  PENDING
  AUTHORIZED
  CAPTURED
  FAILED
  CANCELLED
  REFUNDED
  PARTIALLY_REFUNDED
  VOIDED
  PARTIALLY_PAID
  PAID
}

enum PaymentMethodType {
  CREDIT_CARD
  DEBIT_CARD
  BANK_ACCOUNT
  DIGITAL_WALLET
  CRYPTOCURRENCY
  GIFT_CARD
  STORE_CREDIT
}

enum RefundStatus {
  PENDING
  PROCESSING
  SUCCESS
  FAILED
  CANCELLED
}

enum TransactionType {
  AUTHORIZATION
  CAPTURE
  REFUND
  VOID
  FEE
}

enum TransactionStatus {
  PENDING
  PROCESSING
  SUCCESS
  FAILED
  CANCELLED
  ERROR
  FAILURE
}

# Add the missing TransactionKind enum
enum TransactionKind {
  AUTHORIZATION
  CAPTURE
  SALE
  VOID
  REFUND
}

# Input Types
input PaymentFilter {
  orderId: ID
  customerId: ID
  merchantId: ID
  status: PaymentStatus
  gateway: String
  limit: Int
  offset: Int
}

input CreatePaymentInput {
  orderId: ID
  customerId: ID
  merchantId: ID!
  amount: Float!
  currency: String!
  paymentMethodId: String!
  billingAddress: AddressInput
  description: String
  metadata: JSON
}

input RefundPaymentInput {
  amount: Float!
  reason: String
  description: String
  metadata: JSON
}

input CreatePaymentMethodInput {
  customerId: ID!
  merchantId: ID!
  type: PaymentMethodType!
  token: String!
  isDefault: Boolean
  billingAddress: AddressInput
  metadata: JSON
}

input UpdatePaymentMethodInput {
  isDefault: Boolean
  billingAddress: AddressInput
  metadata: JSON
}

input AddressInput {
  firstName: String
  lastName: String
  company: String
  street1: String
  street2: String
  city: String
  state: String
  country: String
  postalCode: String
  phone: String
  latitude: Float
  longitude: Float
}

# Scalar for JSON data
scalar JSON