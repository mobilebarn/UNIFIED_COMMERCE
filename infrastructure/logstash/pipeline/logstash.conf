input {
  # Listen for logs from Docker containers
  tcp {
    port => 5000
    codec => json_lines
  }

  # Listen for HTTP log submissions
  http {
    port => 8080
    codec => json
  }

  # File input for log files
  file {
    path => "/var/log/unified-commerce/*.log"
    start_position => "beginning"
    codec => json
  }
}

filter {
  # Add index pattern based on service name
  if [service] {
    mutate {
      add_field => { "[@metadata][index]" => "unified-commerce-%{service}-%{+YYYY.MM.dd}" }
    }
  } else {
    mutate {
      add_field => { "[@metadata][index]" => "unified-commerce-logs-%{+YYYY.MM.dd}" }
    }
  }

  # Parse timestamp if it exists
  if [@timestamp] {
    date {
      match => [ "@timestamp", "ISO8601" ]
    }
  }

  # Add environment tag
  mutate {
    add_tag => [ "unified-commerce", "microservices" ]
    add_field => { "environment" => "development" }
  }

  # Parse error messages and stack traces
  if [level] == "error" and [message] {
    grok {
      match => { 
        "message" => "(?<error_type>[A-Za-z]+Error): (?<error_message>.*)"
      }
      tag_on_failure => []
    }
  }

  # Parse HTTP request logs
  if [endpoint] and [method] and [status] {
    mutate {
      add_tag => [ "http-request" ]
    }
  }

  # Parse database operation logs
  if [query] or [database] {
    mutate {
      add_tag => [ "database" ]
    }
  }
}

output {
  # Output to Elasticsearch
  elasticsearch {
    hosts => ["unified-commerce-elasticsearch:9200"]
    index => "%{[@metadata][index]}"
    template_name => "unified-commerce"
    template => "/usr/share/logstash/templates/unified-commerce-template.json"
    template_overwrite => true
  }

  # Debug output to stdout (can be removed in production)
  stdout {
    codec => rubydebug
  }
}
