// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"fmt"
	"io"
	"strconv"
)

type CategoryFilter struct {
	MerchantID *string `json:"merchantId,omitempty"`
	ParentID   *string `json:"parentId,omitempty"`
	IsVisible  *bool   `json:"isVisible,omitempty"`
	Limit      *int    `json:"limit,omitempty"`
	Offset     *int    `json:"offset,omitempty"`
}

type CollectionFilter struct {
	MerchantID *string `json:"merchantId,omitempty"`
	IsVisible  *bool   `json:"isVisible,omitempty"`
	Limit      *int    `json:"limit,omitempty"`
	Offset     *int    `json:"offset,omitempty"`
}

type CreateBrandInput struct {
	MerchantID     string  `json:"merchantId"`
	Name           string  `json:"name"`
	Description    *string `json:"description,omitempty"`
	Logo           *string `json:"logo,omitempty"`
	SeoTitle       *string `json:"seoTitle,omitempty"`
	SeoDescription *string `json:"seoDescription,omitempty"`
	Metafields     *string `json:"metafields,omitempty"`
}

type CreateCategoryInput struct {
	MerchantID     string  `json:"merchantId"`
	Name           string  `json:"name"`
	Description    *string `json:"description,omitempty"`
	ParentID       *string `json:"parentId,omitempty"`
	SeoTitle       *string `json:"seoTitle,omitempty"`
	SeoDescription *string `json:"seoDescription,omitempty"`
	SortOrder      *int    `json:"sortOrder,omitempty"`
	IsVisible      *bool   `json:"isVisible,omitempty"`
	Image          *string `json:"image,omitempty"`
	Metafields     *string `json:"metafields,omitempty"`
}

type CreateCollectionInput struct {
	MerchantID     string                `json:"merchantId"`
	Title          string                `json:"title"`
	Description    *string               `json:"description,omitempty"`
	SeoTitle       *string               `json:"seoTitle,omitempty"`
	SeoDescription *string               `json:"seoDescription,omitempty"`
	SortOrder      *CollectionSortOrder  `json:"sortOrder,omitempty"`
	IsVisible      *bool                 `json:"isVisible,omitempty"`
	Image          *string               `json:"image,omitempty"`
	RulesMatch     *CollectionRulesMatch `json:"rulesMatch,omitempty"`
	Metafields     *string               `json:"metafields,omitempty"`
}

type CreateProductInput struct {
	MerchantID     string          `json:"merchantId"`
	Title          string          `json:"title"`
	Description    *string         `json:"description,omitempty"`
	Vendor         *string         `json:"vendor,omitempty"`
	ProductType    *string         `json:"productType,omitempty"`
	Tags           []string        `json:"tags,omitempty"`
	Status         *ProductStatus  `json:"status,omitempty"`
	PublishedScope *PublishedScope `json:"publishedScope,omitempty"`
	SeoTitle       *string         `json:"seoTitle,omitempty"`
	SeoDescription *string         `json:"seoDescription,omitempty"`
	CategoryID     *string         `json:"categoryId,omitempty"`
	BrandID        *string         `json:"brandId,omitempty"`
	Metafields     *string         `json:"metafields,omitempty"`
}

type CreateProductVariantInput struct {
	ProductID         string           `json:"productId"`
	Title             string           `json:"title"`
	Sku               string           `json:"sku"`
	Barcode           *string          `json:"barcode,omitempty"`
	Price             float64          `json:"price"`
	CompareAtPrice    *float64         `json:"compareAtPrice,omitempty"`
	CostPrice         *float64         `json:"costPrice,omitempty"`
	InventoryQuantity *int             `json:"inventoryQuantity,omitempty"`
	InventoryPolicy   *InventoryPolicy `json:"inventoryPolicy,omitempty"`
	Weight            *float64         `json:"weight,omitempty"`
	WeightUnit        *string          `json:"weightUnit,omitempty"`
	RequiresShipping  *bool            `json:"requiresShipping,omitempty"`
	Taxable           *bool            `json:"taxable,omitempty"`
	TaxCode           *string          `json:"taxCode,omitempty"`
	Option1           *string          `json:"option1,omitempty"`
	Option2           *string          `json:"option2,omitempty"`
	Option3           *string          `json:"option3,omitempty"`
	Metafields        *string          `json:"metafields,omitempty"`
}

type Mutation struct {
}

type ProductFilter struct {
	MerchantID     *string         `json:"merchantId,omitempty"`
	Status         *ProductStatus  `json:"status,omitempty"`
	ProductType    *string         `json:"productType,omitempty"`
	Vendor         *string         `json:"vendor,omitempty"`
	CategoryID     *string         `json:"categoryId,omitempty"`
	BrandID        *string         `json:"brandId,omitempty"`
	CollectionID   *string         `json:"collectionId,omitempty"`
	Tags           []string        `json:"tags,omitempty"`
	Search         *string         `json:"search,omitempty"`
	PublishedScope *PublishedScope `json:"publishedScope,omitempty"`
	Limit          *int            `json:"limit,omitempty"`
	Offset         *int            `json:"offset,omitempty"`
}

type Query struct {
}

type UpdateBrandInput struct {
	Name           *string `json:"name,omitempty"`
	Description    *string `json:"description,omitempty"`
	Logo           *string `json:"logo,omitempty"`
	SeoTitle       *string `json:"seoTitle,omitempty"`
	SeoDescription *string `json:"seoDescription,omitempty"`
	Metafields     *string `json:"metafields,omitempty"`
}

type UpdateCategoryInput struct {
	Name           *string `json:"name,omitempty"`
	Description    *string `json:"description,omitempty"`
	ParentID       *string `json:"parentId,omitempty"`
	SeoTitle       *string `json:"seoTitle,omitempty"`
	SeoDescription *string `json:"seoDescription,omitempty"`
	SortOrder      *int    `json:"sortOrder,omitempty"`
	IsVisible      *bool   `json:"isVisible,omitempty"`
	Image          *string `json:"image,omitempty"`
	Metafields     *string `json:"metafields,omitempty"`
}

type UpdateCollectionInput struct {
	Title          *string               `json:"title,omitempty"`
	Description    *string               `json:"description,omitempty"`
	SeoTitle       *string               `json:"seoTitle,omitempty"`
	SeoDescription *string               `json:"seoDescription,omitempty"`
	SortOrder      *CollectionSortOrder  `json:"sortOrder,omitempty"`
	IsVisible      *bool                 `json:"isVisible,omitempty"`
	Image          *string               `json:"image,omitempty"`
	RulesMatch     *CollectionRulesMatch `json:"rulesMatch,omitempty"`
	Metafields     *string               `json:"metafields,omitempty"`
}

type UpdateProductInput struct {
	Title          *string         `json:"title,omitempty"`
	Description    *string         `json:"description,omitempty"`
	Vendor         *string         `json:"vendor,omitempty"`
	ProductType    *string         `json:"productType,omitempty"`
	Tags           []string        `json:"tags,omitempty"`
	Status         *ProductStatus  `json:"status,omitempty"`
	PublishedScope *PublishedScope `json:"publishedScope,omitempty"`
	SeoTitle       *string         `json:"seoTitle,omitempty"`
	SeoDescription *string         `json:"seoDescription,omitempty"`
	CategoryID     *string         `json:"categoryId,omitempty"`
	BrandID        *string         `json:"brandId,omitempty"`
	Metafields     *string         `json:"metafields,omitempty"`
}

type UpdateProductVariantInput struct {
	Title             *string          `json:"title,omitempty"`
	Sku               *string          `json:"sku,omitempty"`
	Barcode           *string          `json:"barcode,omitempty"`
	Price             *float64         `json:"price,omitempty"`
	CompareAtPrice    *float64         `json:"compareAtPrice,omitempty"`
	CostPrice         *float64         `json:"costPrice,omitempty"`
	InventoryQuantity *int             `json:"inventoryQuantity,omitempty"`
	InventoryPolicy   *InventoryPolicy `json:"inventoryPolicy,omitempty"`
	Weight            *float64         `json:"weight,omitempty"`
	WeightUnit        *string          `json:"weightUnit,omitempty"`
	RequiresShipping  *bool            `json:"requiresShipping,omitempty"`
	Taxable           *bool            `json:"taxable,omitempty"`
	TaxCode           *string          `json:"taxCode,omitempty"`
	Option1           *string          `json:"option1,omitempty"`
	Option2           *string          `json:"option2,omitempty"`
	Option3           *string          `json:"option3,omitempty"`
	Metafields        *string          `json:"metafields,omitempty"`
}

type User struct {
	ID string `json:"id"`
}

func (User) IsEntity() {}

type CollectionRulesMatch string

const (
	CollectionRulesMatchAll CollectionRulesMatch = "ALL"
	CollectionRulesMatchAny CollectionRulesMatch = "ANY"
)

var AllCollectionRulesMatch = []CollectionRulesMatch{
	CollectionRulesMatchAll,
	CollectionRulesMatchAny,
}

func (e CollectionRulesMatch) IsValid() bool {
	switch e {
	case CollectionRulesMatchAll, CollectionRulesMatchAny:
		return true
	}
	return false
}

func (e CollectionRulesMatch) String() string {
	return string(e)
}

func (e *CollectionRulesMatch) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CollectionRulesMatch(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CollectionRulesMatch", str)
	}
	return nil
}

func (e CollectionRulesMatch) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CollectionSortOrder string

const (
	CollectionSortOrderAlphaAsc    CollectionSortOrder = "ALPHA_ASC"
	CollectionSortOrderAlphaDesc   CollectionSortOrder = "ALPHA_DESC"
	CollectionSortOrderBestSelling CollectionSortOrder = "BEST_SELLING"
	CollectionSortOrderCreated     CollectionSortOrder = "CREATED"
	CollectionSortOrderCreatedDesc CollectionSortOrder = "CREATED_DESC"
	CollectionSortOrderManual      CollectionSortOrder = "MANUAL"
	CollectionSortOrderPriceAsc    CollectionSortOrder = "PRICE_ASC"
	CollectionSortOrderPriceDesc   CollectionSortOrder = "PRICE_DESC"
)

var AllCollectionSortOrder = []CollectionSortOrder{
	CollectionSortOrderAlphaAsc,
	CollectionSortOrderAlphaDesc,
	CollectionSortOrderBestSelling,
	CollectionSortOrderCreated,
	CollectionSortOrderCreatedDesc,
	CollectionSortOrderManual,
	CollectionSortOrderPriceAsc,
	CollectionSortOrderPriceDesc,
}

func (e CollectionSortOrder) IsValid() bool {
	switch e {
	case CollectionSortOrderAlphaAsc, CollectionSortOrderAlphaDesc, CollectionSortOrderBestSelling, CollectionSortOrderCreated, CollectionSortOrderCreatedDesc, CollectionSortOrderManual, CollectionSortOrderPriceAsc, CollectionSortOrderPriceDesc:
		return true
	}
	return false
}

func (e CollectionSortOrder) String() string {
	return string(e)
}

func (e *CollectionSortOrder) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CollectionSortOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CollectionSortOrder", str)
	}
	return nil
}

func (e CollectionSortOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InventoryPolicy string

const (
	InventoryPolicyDeny     InventoryPolicy = "DENY"
	InventoryPolicyContinue InventoryPolicy = "CONTINUE"
)

var AllInventoryPolicy = []InventoryPolicy{
	InventoryPolicyDeny,
	InventoryPolicyContinue,
}

func (e InventoryPolicy) IsValid() bool {
	switch e {
	case InventoryPolicyDeny, InventoryPolicyContinue:
		return true
	}
	return false
}

func (e InventoryPolicy) String() string {
	return string(e)
}

func (e *InventoryPolicy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InventoryPolicy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InventoryPolicy", str)
	}
	return nil
}

func (e InventoryPolicy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProductStatus string

const (
	ProductStatusActive   ProductStatus = "ACTIVE"
	ProductStatusArchived ProductStatus = "ARCHIVED"
	ProductStatusDraft    ProductStatus = "DRAFT"
)

var AllProductStatus = []ProductStatus{
	ProductStatusActive,
	ProductStatusArchived,
	ProductStatusDraft,
}

func (e ProductStatus) IsValid() bool {
	switch e {
	case ProductStatusActive, ProductStatusArchived, ProductStatusDraft:
		return true
	}
	return false
}

func (e ProductStatus) String() string {
	return string(e)
}

func (e *ProductStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductStatus", str)
	}
	return nil
}

func (e ProductStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PublishedScope string

const (
	PublishedScopeGlobal PublishedScope = "GLOBAL"
	PublishedScopeWeb    PublishedScope = "WEB"
	PublishedScopePos    PublishedScope = "POS"
)

var AllPublishedScope = []PublishedScope{
	PublishedScopeGlobal,
	PublishedScopeWeb,
	PublishedScopePos,
}

func (e PublishedScope) IsValid() bool {
	switch e {
	case PublishedScopeGlobal, PublishedScopeWeb, PublishedScopePos:
		return true
	}
	return false
}

func (e PublishedScope) String() string {
	return string(e)
}

func (e *PublishedScope) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PublishedScope(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PublishedScope", str)
	}
	return nil
}

func (e PublishedScope) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SearchSuggestionType string

const (
	SearchSuggestionTypeProduct  SearchSuggestionType = "PRODUCT"
	SearchSuggestionTypeCategory SearchSuggestionType = "CATEGORY"
	SearchSuggestionTypeBrand    SearchSuggestionType = "BRAND"
)

var AllSearchSuggestionType = []SearchSuggestionType{
	SearchSuggestionTypeProduct,
	SearchSuggestionTypeCategory,
	SearchSuggestionTypeBrand,
}

func (e SearchSuggestionType) IsValid() bool {
	switch e {
	case SearchSuggestionTypeProduct, SearchSuggestionTypeCategory, SearchSuggestionTypeBrand:
		return true
	}
	return false
}

func (e SearchSuggestionType) String() string {
	return string(e)
}

func (e *SearchSuggestionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SearchSuggestionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SearchSuggestionType", str)
	}
	return nil
}

func (e SearchSuggestionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
